% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/LFL.R
\name{LFL}
\alias{LFL}
\title{LFL-MBB optimal block lenght selection algorithm}
\usage{
LFL(data, statistic, R = 100L, nsteps = 5L, l.init = NULL,
  type.optm = 0, type.est = "bias.variance", ran.gen = function(tser,
  n.sim, args) tser, ran.args = NULL, allow.parallel = TRUE, seed = 123,
  packages = NULL, export = NULL, ...)
}
\arguments{
\item{data}{A univariate or multivariate time series.
It might be vector, matrix or data frame to be passed to
statistic.}

\item{statistic}{A function which when applied to data
returns a vector containing the statistic of interest.
Each time statistic is called it is passed a time series
 of length n which is of the same class as the original
 tseries. Any other arguments which statistic takes must
  remain constant for each bootstrap replicate and
  should be supplied through the . . . argument to
  tsboot.}

\item{R}{A positive integer giving the number of
bootstrap replicates required. The default value is 100.}

\item{nsteps}{A positive integer with the number of steps
(iterations) in the HHJ algorithm. The default value is 5.}

\item{l.init}{A positive integer smaller then the number
of observations (n.obs.) in \code{data} (i.e. the length
 of the time series), indicating the size of the subset
 in the \bold{HHJ} algorithm. The default value is
 'default', in which \eqn{m.init = round(c1*n.obs.^(1/(r+4)))}}

\item{type.optm}{0 for mean of the parameters vector
or a positive integer giving the index of the desired
parameter to optimize in the same order as provided by
statistic. For more details see the section
\strong{"Details"} bellow.#'}

\item{type.est}{A character describing the type of
estimation being undertaken. Accepted values are:
"bias.variance" and "distribution.quantile".
The default value is 'bias.variance'.}

\item{ran.gen}{This is a function of three arguments. The first
argument is a time series, it is the result of selecting
\code{n.sim} observations from \code{tseries} by some scheme
and converting the result back into a time series of the
same form as \code{tseries} (with length \code{n.sim}).
The second argument to \code{ran.gen} is always the value
\code{n.sim}, and the third argument is \code{ran.args},
which is used to supply any other objects needed by
\code{ran.gen}.}

\item{ran.args}{This will be supplied to \code{ran.gen}
each time it is called. If \code{ran.gen} needs any
extra arguments then they should be supplied as components
of \code{ran.args}. Multiple arguments may be passed by
making \code{ran.args} a list. If \code{ran.args} is
\code{NULL} then it should not be used within
\code{ran.gen} but note that \code{ran.gen} must still
have its third argument.}

\item{allow.parallel}{Logical TRUE/FALSE indicating
whether parallel computation via the foreach package
should be used. The default value is TRUE. OBS:paralllel
 backend must be registered prior to calling \strong{HHJ}.}

\item{seed}{Numeric, the seed to \code{set.seed()} for
replicable examples.}

\item{packages}{If \code{allow.parallel = TRUE}.
A character vector with the lisf of
packages required by \code{statisitc}.}

\item{export}{If \code{allow.parallel = TRUE}.
A character vector with the lisf of
objects (functions, etc...) required by \code{statisitc}.}

\item{\dots}{Extra argumetns to \code{statistic} may be
supplied here. Beware of partial matching to the
arguments of \code{\link{tsboot2}}.}
}
\value{
A dataframe, the first column for the iteration
step the second and third for the estimated optimal block length.
}
\description{
This functions performs the data-based algorithm of Lahiri,
Furukawa and Lee (2005), henceforth \strong{LFL}, for
 the selection of optimal block length sizes in the case
  of block bootstrap of Kunsch (1989).
}
\details{
This functions implements the iterative version of the
Lahiri, Furukawa and Lee (2005) algorithm. Here some
modifications are implemented in the fashion of Barroso
(2017). Namely, a vectorized algorithm is implemented
where the user might supply which parameter to optimize
over or use a default value. The default value is obtained
by minimizin the mean MSE vector (if a vector or
parameters is returned by statistic). For the MBB step
the \code{\link{tsboot2}},a modification of the
\code{\link[boot]{tsboot}} function from the
\pkg{boot} package, is used.
}
\note{
This function is not working properly. Wait for an
update.
For bugs and further requests please refer
to \url{https://github.com/matheusbarroso/dboot}
}
\examples{
\dontrun{
library(dboot)
library(gamlss)
library(doParallel)
no_cores <- if(detectCores()==1) 1 else detectCores() -1
registerDoParallel(no_cores)
bootf <- function (db,ord,fam) {
 fit2 <- garmaFit2(yt~x-1,data=db,order=ord,family=fam,tail=0,control=list(iter.max=1000))
 return(fit2$coef)}
ord <- c(1,1) ; fam="GA"
db <- example_LFL

LFL(db,bootf,ord=ord,fam=fam,export=c("garmaFit2"),package=c("gamlss"))}
}
\references{
Kunsch, Hans R. 1989. The Jakknife and the
Bootstrap For General Stationary Observations.
The Annals of Statistics. 1989, Vol. 17, 3, pp. 1217-1241.

Lahiri, Soumendra, Furukawa, Kyoji and Lee, Yd. 2007.
A nonparametric plug-in rule for selecting optimal block lengths
for block bootstrap methods. Statistical Methodology. July, 2007,
Vol. 4, 3, pp. 292-321.

Barroso, Matheus de V. 2018.  BOOTSTRAP METHODS FOR
GENERALIZED AUTOREGRESSIVE MOVING AVERAGE MODELS
}
\author{
Matheus de Vasconcellos Barroso
}
