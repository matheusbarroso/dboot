% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/HHJ.R
\name{HHJ}
\alias{HHJ}
\title{HHJ-MBB optimal block lenght selection algorithm}
\usage{
HHJ(data, statistic, R = 100, nsteps = 5L, type.est = "bias.variance",
  type.optm = 0, allow.parallel = TRUE, errorhandling = "try",
  n.try = 3, m.init = "default", type.sub.blocks = "fast", seed = 123,
  export, ...)
}
\arguments{
\item{data}{A univariate or multivariate time series.
It might be vector, matrix or data frame to be passed to
statistic.}

\item{statistic}{A function which when applied to data
returns a vector containing the statistic of interest.
Each time statistic is called it is passed a time series
 of length n which is of the same class as the original
 tseries. Any other arguments which statistic takes must
  remain constant for each bootstrap replicate and
  should be supplied through the . . . argument to
  tsboot.}

\item{R}{A positive integer giving the number of
bootstrap replicates required. The default value is 100.}

\item{nsteps}{A positive integer with the number of steps
(iterations) in the HHJ algorithm. The default value is 5.}

\item{type.est}{A character describing the type of
estimation being undertaken. Accepted values are:
'bias.variance', 'one.sided.distribution' and
'two.sided.distribution. The default value is
 'bias.variance'.}

\item{type.optm}{0 for mean of the parameters vector
or a positive integer giving the index of the desired
parameter to optimize in the same order as provided by
statistic. For more details see the section
\strong{"Details"} bellow.}

\item{allow.parallel}{Logical TRUE/FALSE indicating
whether parallel computation via the foreach package
should be used. The default value is TRUE. OBS:paralllel
 backend must be registered prior to calling \strong{HHJ}.}

\item{errorhandling}{A character, accepted values are 'try' and 'pass'.}

\item{n.try}{A positive integer indicating the maximum
number of tries if errorhandling='try'. The default
value is 3.}

\item{m.init}{A positive integer smaller then the number
of observations (n.obs.) in \code{data} (i.e. the length
 of the time series), indicating the size of the subset
 in the \bold{HHJ} algorithm. The default value is
 'default', in which \code{m.init=round(n.obs.^(1/3))}}

\item{type.sub.blocks}{A character, accepted values are: 'fast'
and 'complete', the former implements a sampling scheme
 in the subsets of \code{m (or m.init)}, where only
 three subsets lengths are evaluated. In the latter all
 subsets lenghts are evaluated. For a large dataset the
 option 'complete' might take too long. For more details
  see the section \strong{"Details"} bellow.}

\item{seed}{Numeric, the seed to \code{set.seed()} for
replicable examples.}

\item{export}{A character vector with the name of variables
to export to the foreach loop.}

\item{\dots}{Further argumetns to be passed to the
\code{\link[boot]{tsboot}}  function.}
}
\value{
A dataframe, the first column for the iteration
step and the second for the estimated optimal block length.
}
\description{
This functions performs the data-based algorithm of Hall,
Horowitz and Jing (1995), henceforth \strong{HHJ}, for
 the selection of optimal block length sizes in the case
  of block bootstrap of Kunsch (1989).
}
\details{
This functions implements the iterative version of the
Hall, Horowitz and Jing (1995) algorithm. Here some
modifications are implemented in the fashion of Barroso
(2017). Namely, a vectorized algorithm is implemented
where the user might supply which parameter to optimize
over or use a default value. The default value is obtained
by minimizin the mean MSE vector (if a vector or
parameters is returned by statistic). For the MBB step
the \code{\link[boot]{tsboot}} function from the
\pkg{boot} package is used. Additionaly, with the
 argument \code{type.sub.blocks} the user might use a
 sampling sche on the subsets of \code{m.init}. There is
  one sample from the quantile 1/3, another for the 2/3
  and the last one for the 1/3-2/3.
}
\note{
For bugs and further requests please refer
to \url{https://github.com/matheusbarroso/dboot}
}
\examples{
\dontrun{library(dboot)
data(exampleHHJ,package='dboot') # this is a realization of Poisson-Garma model.
familia <- "PO"
ordem <- c(0,1)
library(gamlss)
library(boot)

bootf <- function (db) {
 fit2 <- garmaFit2(yt~x-1,data=db,order=ordem,family=familia,tail=0,control=list(iter.max=1000))
 return(fit2$coef)}

library(doParallel)
no_cores <- if(detectCores()==1) 1 else detectCores() -1
registerDoParallel(no_cores)

HHJ(db,bootf,errorhandling="try",nsteps=1,export=c("garmaFit2","familia","ordem"))

HHJ(db,bootf,errorhandling="try",nsteps=2,export=c("garmaFit2","familia","ordem"),n.try=5)

HHJ(db,bootf,errorhandling="try",nsteps=2,export=c("garmaFit2","familia","ordem"),type.optm=2)

HHJ(db,bootf,errorhandling="try",nsteps=3,export=c("garmaFit2","familia","ordem"),m.init=6)

HHJ(db,bootf,errorhandling="try",nsteps=1,export=c("garmaFit2","familia","ordem"),m.init=6,allow.parallel=FALSE)}

}
\references{
Kunsch, Hans R. 1989. The Jakknife and the
Bootstrap For General Stationary Observations.
The Annals of Statistics. 1989, Vol. 17, 3, pp. 1217-1241.

Hall, P., Horowitz, J. L e Jing, B-Y. 1995. On blocking
rules for the bootstrap with dependent data. Biometrika. 82, 1995, pp. 561-574.

Barroso, Matheus de V. 2018.  BOOTSTRAP METHODS FOR
GENERALIZED AUTOREGRESSIVE MOVING AVERAGE MODELS
}
\author{
Matheus de Vasconcellos Barroso
}
