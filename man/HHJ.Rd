% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/HHJ.R
\name{HHJ}
\alias{HHJ}
\title{HHJ-MBB optimal block lenght selection algorithm}
\usage{
HHJ(data, statistic, R = 100L, nsteps = 5L, type.est = "bias.variance",
  type.optm = 0, ran.gen = function(tser, n.sim, args) tser,
  ran.args = NULL, allow.parallel = TRUE, errorhandling = "try",
  n.try = 5L, m.init = "default", type.sub.blocks = "fast", seed = 123,
  packages = NULL, export = NULL, ...)
}
\arguments{
\item{data}{A univariate or multivariate time series.
It might be vector, matrix or data frame to be passed to
statistic.}

\item{statistic}{A function which when applied to data
returns a vector containing the statistic of interest.
Each time statistic is called it is passed a time series
 of length n which is of the same class as the original
 tseries. Any other arguments which statistic takes must
  remain constant for each bootstrap replicate and
  should be supplied through the . . . argument to
  tsboot.}

\item{R}{A positive integer giving the number of
bootstrap replicates required. The default value is 100.}

\item{nsteps}{A positive integer with the number of steps
(iterations) in the HHJ algorithm. The default value is 5.}

\item{type.est}{A character describing the type of
estimation being undertaken. Accepted values are:
'bias.variance', 'one.sided.distribution' and
'two.sided.distribution'. The default value is
 'bias.variance'.}

\item{type.optm}{0 for mean of the parameters vector
or a positive integer giving the index of the desired
parameter to optimize in the same order as provided by
statistic. For more details see the section
\strong{"Details"} bellow.}

\item{ran.gen}{This is a function of three arguments. The first
argument is a time series, it is the result of selecting
\code{n.sim} observations from \code{tseries} by some scheme
and converting the result back into a time series of the
same form as \code{tseries} (with length \code{n.sim}).
The second argument to \code{ran.gen} is always the value
\code{n.sim}, and the third argument is \code{ran.args},
which is used to supply any other objects needed by
\code{ran.gen}.}

\item{ran.args}{This will be supplied to \code{ran.gen}
each time it is called. If \code{ran.gen} needs any
extra arguments then they should be supplied as components
of \code{ran.args}. Multiple arguments may be passed by
making \code{ran.args} a list. If \code{ran.args} is
\code{NULL} then it should not be used within
\code{ran.gen} but note that \code{ran.gen} must still
have its third argument.}

\item{allow.parallel}{Logical TRUE/FALSE indicating
whether parallel computation via the foreach package
should be used. The default value is TRUE. OBS:paralllel
 backend must be registered prior to calling \strong{HHJ}.}

\item{errorhandling}{A character, accepted values are 'try' and 'pass'.}

\item{n.try}{A positive integer indicating the maximum
number of tries if errorhandling='try'. The default
value is 3.}

\item{m.init}{A positive integer smaller then the number
of observations (n.obs.) in \code{data} (i.e. the length
 of the time series), indicating the size of the subset
 in the \bold{HHJ} algorithm. The default value is
 'default', in which \code{m.init=round(n.obs.^(1/3))}}

\item{type.sub.blocks}{A character, accepted values are: 'fast'
and 'complete', the former implements a sampling scheme
 in the subsets of \code{m (or m.init)}, where only
 three subsets lengths are evaluated. In the latter all
 subsets lenghts are evaluated. For a large dataset the
 option 'complete' might take too long. For more details
  see the section \strong{"Details"} bellow.}

\item{seed}{Numeric, the seed to \code{set.seed()} for
replicable examples.}

\item{packages}{If \code{allow.parallel = TRUE}.
A character vector with the lisf of
packages required by \code{statisitc}.}

\item{export}{If \code{allow.parallel = TRUE}.
A character vector with the lisf of
objects (functions, etc...) required by \code{statisitc}.}

\item{\dots}{Extra argumetns to \code{statistic} may be
supplied here. Beware of partial matching to the
arguments of \code{\link{tsboot2}}.}
}
\value{
A dataframe, the first column for the iteration
step and the second for the estimated optimal block length.
}
\description{
This functions performs the data-based algorithm of Hall,
Horowitz and Jing (1995), henceforth \strong{HHJ}, for
 the selection of optimal block length sizes in the case
  of block bootstrap of Kunsch (1989).
}
\details{
This functions implements the iterative version of the
Hall, Horowitz and Jing (1995) algorithm. Here some
modifications are implemented in the fashion of Barroso
(2017). Namely, a vectorized algorithm is implemented
where the user might supply which parameter to optimize
over or use a default value. The default value is obtained
by minimizin the mean MSE vector (if a vector or
parameters is returned by statistic). For the MBB step
the \code{\link[boot]{tsboot}} function from the
\pkg{boot} package is used. Additionaly, with the
 argument \code{type.sub.blocks} the user might use a
 sampling sche on the subsets of \code{m.init}. There is
  one sample from the quantile 1/3, another for the 2/3
  and the last one for the 1/3-2/3.
}
\note{
For bugs and further requests please refer
to \url{https://github.com/matheusbarroso/dboot}
}
\examples{
\dontrun{
library(gamlss)
library(dboot)
db <- example_HHJ
fam <- "PO"
ord <- c(0,1)

library(doParallel)
no_cores <- if(detectCores()==1) 1 else detectCores() -1
registerDoParallel(no_cores)

HHJ(db,bootf,R = 10,nsteps=1,ord=ord,fam=fam,
export=c("garmaFit2"), packages=c("gamlss"))

HHJ(db,bootf,R = 10, errorhandling="pass",ord=ord,seed=124
fam=fam,export=c("garmaFit2"),  packages=c("gamlss"),n.try=3)

HHJ(db,bootf,R = 10,nsteps=2,ord=ord,fam=fam,
export=c("garmaFit2"),  packages=c("gamlss"),n.try=2)

HHJ(db,bootf,R = 10,nsteps=1,ord=ord,fam=fam,
export=c("garmaFit2"), packages=c("gamlss"),type.sub.blocks="complete")

HHJ(db,bootf,R = 10,nsteps=2,ord=ord,fam=fam,
export=c("garmaFit2"),  packages=c("gamlss"),type.optm=2)

HHJ(db,bootf,R = 10,nsteps=3,ord=ord,fam=fam,
export=c("garmaFit2"), packages=c("gamlss"),m.init=6)

HHJ(db,bootf,R = 10,nsteps=1,ord=ord,fam=fam,
export=c("garmaFit2"), packages=c("gamlss"),m.init=6,allow.parallel=FALSE)
}
}
\references{
Kunsch, Hans R. 1989. The Jakknife and the
Bootstrap For General Stationary Observations.
The Annals of Statistics. 1989, Vol. 17, 3, pp. 1217-1241.

Hall, P., Horowitz, J. L e Jing, B-Y. 1995. On blocking
rules for the bootstrap with dependent data. Biometrika. 82, 1995, pp. 561-574.

Barroso, Matheus de V. 2018.  BOOTSTRAP METHODS FOR
GENERALIZED AUTOREGRESSIVE MOVING AVERAGE MODELS
}
\author{
Matheus de Vasconcellos Barroso
}
